/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./Demo/main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./Demo/main.js":
/*!**********************!*\
  !*** ./Demo/main.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const markov = __webpack_require__(/*! ../Markov.js */ \"./Markov.js\");\nconst Haystack = __webpack_require__(/*! haystack-search */ \"./node_modules/haystack-search/Haystack.js\");\n\nconst haystack = new Haystack({\n  flexibility: 0,\n  caseSensitive: false,\n  ignoreStopWords: false,\n  stemming: false\n});\n\nlet vocabulary;\nconst keyupEvent = new Event('keyup');\nconst userInputBox = document.getElementById('user-input');\nconst textGenerateBox = document.getElementById('text-generation');\nconst suggestionButtons = document.getElementsByClassName('suggestion');\nconst predictionInput = document.getElementById('prediction-input');\nconst predictCol1 = document.querySelector('#column-1 ul');\nconst columnOneLi = document.querySelectorAll('#column-1 li');\nconst predictCol2 = document.querySelector('#column-2 ul');\nconst columnTwoLi = document.querySelectorAll('#column-2 li');\nconst predictCol3 = document.querySelector('#column-3 ul');\nconst columnThreeLi = document.querySelectorAll('#column-3 li');\nconst treeWordsNext = document.querySelectorAll('#column-1 li');\n\ndocument.getElementById('loading-data').style.display = 'block';\nmarkov.loadVocabulary().then(() => {\n  document.getElementById('loading-data').style.display = 'none';\n  vocabulary = markov.getVocabulary();\n\n  if (Object.keys(vocabulary).length > 0) {\n    const vocabCount = Object.keys(vocabulary).length.toString().replace(/\\B(?=(\\d{3})+(?!\\d))/g, \",\");\n    document.getElementById('vocab-info').innerHTML = \"<i class='fas fa-database'></i> Vocabulary: <span>\" + vocabCount + \"</span> words\";\n  }\n  else {\n    document.getElementById('vocab-info').innerHTML = \"<i class='fas fa-database'></i> No Vocabulary found\";\n  }\n\n  refreshButtons();\n});\n\n\n// ===== Event Handlers ===================================\ndocument.getElementById('train-btn').addEventListener('click', (e) => {\n  document.getElementById('train-btn').innerText = \"Training...\";\n  const text = document.getElementById('training-box').value.trim();\n  markov.train(text).then(() => {\n    console.log(\"Training complete\");\n    document.getElementById('train-btn').innerText = \"Training Complete!\";\n    vocabulary = markov.getVocabulary();\n    document.getElementById('vocab-info').innerHTML = \"<i class='fas fa-database'></i> Vocabulary: <span>\" + Object.keys(vocabulary).length.toString().replace(/\\B(?=(\\d{3})+(?!\\d))/g, \",\") + \"</span> words\";\n\n    setTimeout(() => {\n      document.getElementById('train-btn').innerText = \"Train\";\n    }, 5000);\n  });\n  refreshButtons();\n});\n\n\ndocument.querySelectorAll('#sample-text div').forEach(function(book) {\n  book.addEventListener('click', function(e) {\n    e.stopPropagation();\n    if (!book.classList.contains('reading')) {\n      const title = this.getAttribute('data-title');\n      book.classList.add('reading');\n\n      readTextFile(title).then((text) => {\n        // Got text, proceed to training...\n        console.log(\"Reading: '\" + title + \"'\")\n        markov.train(text.trim()).then(() => {\n          console.log(\"Training complete\");\n          vocabulary = markov.getVocabulary();\n          document.getElementById('vocab-info').innerHTML = \"<i class='fas fa-database'></i> Vocabulary: <span>\" + Object.keys(vocabulary).length.toString().replace(/\\B(?=(\\d{3})+(?!\\d))/g, \",\") + \"</span> words\";\n          refreshButtons();\n          book.classList.remove('reading');\n\n          // If 'Read' label isn't present, add it:\n          if (!book.querySelector('p .book-read')) {\n            let span = document.createElement('span');\n            span.classList.add('book-read');\n            span.innerHTML = '<i class=\"fas fa-check\"></i> Read';\n            book.querySelector('p').appendChild(span);\n          }\n        });\n        \n      })\n      .catch((err) => {\n        console.error(err);\n        book.classList.remove('reading');\n      });\n    }\n  });\n});\n\n\ndocument.getElementById('wiki-btn').addEventListener('click', (e) => {\n  const wikiBtn = document.getElementById('wiki-btn');\n  const limit = document.querySelector('.wiki-max').value;\n\n  if (!wikiBtn.classList.contains('btn-loading')) {\n    wikiBtn.innerText = \"Fetching...\";\n    wikiBtn.classList.add('btn-loading');\n\n    readWikipedia(limit)\n    .then( () => {\n      console.log(\"Training complete \\nRead \" + limit + \" entries.\");\n      wikiBtn.classList.remove('btn-loading');\n      wikiBtn.innerText = \"Fetch Text from Wikipedia\";\n      vocabulary = markov.getVocabulary();\n      document.getElementById('vocab-info').innerHTML = \"<i class='fas fa-database'></i> Vocabulary: <span>\" + Object.keys(vocabulary).length.toString().replace(/\\B(?=(\\d{3})+(?!\\d))/g, \",\") + \"</span> words\";\n      refreshButtons();\n    });\n  }\n});\n\n\nuserInputBox.addEventListener('keyup', (e) => {\n  userInputKeyUp();\n});\n\n\nfor (let i=0; i<document.getElementsByClassName(\"nav-btn\").length; i++) {\n  const thisBtn = document.getElementsByClassName(\"nav-btn\")[i];\n\n  thisBtn.addEventListener('click', (e) => {\n    if (!thisBtn.classList.contains('current') && !thisBtn.classList.contains('unavailable')) {\n      document.querySelector('.current').classList.remove('current');\n      thisBtn.classList.add('current');\n\n      switch (e.currentTarget.getAttribute(\"id\")) {\n        case \"training-btn\":\n          document.querySelector('#section-training').style.display = \"block\";\n          document.querySelector('#section-autocomplete').style.display = \"none\";\n          document.querySelector('#section-textgen').style.display = \"none\";\n          document.querySelector('#section-dialogtree').style.display = \"none\";\n          break;\n        case \"autocomplete-btn\":\n          document.querySelector('#section-training').style.display = \"none\";\n          document.querySelector('#section-autocomplete').style.display = \"block\";\n          document.querySelector('#section-textgen').style.display = \"none\";\n          document.querySelector('#section-dialogtree').style.display = \"none\";\n          break;\n        case \"textgen-btn\":\n          document.querySelector('#section-training').style.display = \"none\";\n          document.querySelector('#section-autocomplete').style.display = \"none\";\n          document.querySelector('#section-textgen').style.display = \"block\";\n          document.querySelector('#section-dialogtree').style.display = \"none\";\n          break;\n        case \"dialogtree-btn\":\n          document.querySelector('#section-training').style.display = \"none\";\n          document.querySelector('#section-autocomplete').style.display = \"none\";\n          document.querySelector('#section-textgen').style.display = \"none\";\n          document.querySelector('#section-dialogtree').style.display = \"block\";\n          break;\n      }\n    }\n  })\n}\n\n\nfor (let i=0; i<suggestionButtons.length; i++) {\n  suggestionButtons[i].addEventListener('click', (e) => {\n    if (e.target.innerText.trim() != \"\") {\n      const existingText = userInputBox.value;\n      let newText;\n      if (existingText[existingText.length-1] !== \" \") {\n        // Replace last word\n        let tokens = existingText.split(' ');\n        tokens.pop();\n        newText = tokens.join(' ') + \" \" + e.target.innerText + \" \";\n      }\n      else {\n        // Add new word\n        newText = existingText + e.target.innerText + \" \";\n      }\n      userInputBox.value = newText;\n      userInputKeyUp();\n    }\n    userInputBox.focus();\n  });\n}\n\n\ndocument.getElementById('generateBtn').addEventListener('click', (e) => {\n  const max = document.querySelector('.gen-max').value - 1;\n  textGenerateBox.innerText = markov.generateParagraph(max);\n  if (textGenerateBox.value.length > 0) {\n    document.getElementById('speak-text').style.display = \"inline-block\";\n  }\n});\n\ndocument.getElementById('speak-text').addEventListener('click', (e) => {\n  speakText(textGenerateBox.value);\n});\n\n\npredictionInput.addEventListener('keyup', (e) => {\n  let foundInVocab = getLastWord(cleanText(e.target.value)) in vocabulary;\n\n  if (!foundInVocab || e.target.value == \"\") {\n    predictCol1.style.display = \"none\";\n    predictCol2.style.display = \"none\";\n    predictCol3.style.display = \"none\";\n    document.getElementById('no-branches').style.display = \"block\";\n  }\n  else if (foundInVocab) {\n    document.getElementById('no-branches').style.display = \"none\";\n    const path = markov.predictPath( getLastWord(cleanText(e.target.value)) );\n    if (path.one) {\n      predictCol1.style.display = \"inline-block\";\n      columnOneLi.forEach( (el, index) => {\n        if (path.one[index]) {\n          el.style.display = \"block\";\n          el.innerText = path.one[index];\n        }\n        else {\n          el.style.display = \"none\";\n          el.innerText = \"\";\n        }\n      });\n    }\n    else {\n      predictCol1.style.display = \"none\";\n    }\n    if (path.two) {\n      predictCol2.style.display = \"inline-block\";\n      columnTwoLi.forEach( (el, index) => {\n        if (path.two[index]) {\n          el.style.display = \"block\";\n          el.innerText = path.two[index];\n        }\n        else {\n          el.style.display = \"none\";\n          el.innerText = \"\";\n        }\n      });\n    }\n    else {\n      predictCol2.style.display = \"none\";\n    }\n    if (path.three) {\n      predictCol3.style.display = \"inline-block\";\n      columnThreeLi.forEach( (el, index) => {\n        if (path.three[index]) {\n          el.style.display = \"block\";\n          el.innerText = path.three[index];\n        }\n        else {\n          el.style.display = \"none\";\n          el.innerText = \"\";\n        }\n      });\n    }\n    else {\n      predictCol3.style.display = \"none\";\n    }\n  }\n});\n\nfor (let i=0; i<treeWordsNext.length; i++) {\n  treeWordsNext[i].addEventListener('click', (e) => {\n    const word = e.target.innerText;\n    const firstChar = predictionInput.value[predictionInput.value.length-1] == \" \" ? \"\" : \" \";\n    predictionInput.value = predictionInput.value + firstChar + word + \" \";\n    predictionInput.dispatchEvent(keyupEvent);\n  });\n}\n\n\nasync function readWikipedia(limit) {\n// async function readWikipedia(limit) {\n  for (let i=0; i<limit; i++) {\n    await new Promise((resolve) => {\n      getWikiText()\n      .then((response) => {\n        return markov.train(response);\n      })\n      .then(() => {\n        const progress = Math.floor(((i+1) / limit) * 100) + \"%\";\n        document.getElementById('wiki-btn').innerText = \"Fetching... (\" + progress + \")\";\n        resolve();\n      });\n    });\n  }\n}\n\n\nfunction readTextFile(name) {\n  return new Promise((resolve, reject) => {\n    const rawFile = new XMLHttpRequest();\n    rawFile.open(\"GET\", \"Sample Text/\" + name + \".txt\", true);\n    rawFile.onload = function(e) {\n      if (rawFile.status === 200) {\n        const fileContents = rawFile.responseText;\n        resolve(fileContents);\n      }\n      else {\n        reject;\n      }\n    }\n    rawFile.send();\n  });\n}\n\n\nfunction userInputKeyUp() {\n  const lastChar = userInputBox.value[userInputBox.value.length-1];\n  let words = userInputBox.value.split(\" \");\n  let lastWord = words[words.length-1];\n\n  if (lastChar !== ' ' && lastWord.length > 0) {\n    // Word in progress, guess what it will be\n    const wordPool = Object.keys(vocabulary);\n    const completions = haystack.search(lastWord, wordPool, 3);\n\n    for (let i=0; i<3; i++) {\n      if (completions && completions[i]) {\n        suggestionButtons[i].innerText = completions[i];\n      }\n      else {\n        suggestionButtons[i].innerText = \"\";\n      }\n    }\n  }\n  else {\n    // Guess next word\n    for (let i=0; i<words.length; i++) {\n      if (words[i] === \"\") {\n        words.splice(i, 1);\n      }\n    }\n  \n    lastWord = words[words.length-1];\n    const nextWords = vocabulary[lastWord];\n  \n    for (let i=0; i<3; i++) {\n      if (nextWords && nextWords[i]) {\n        suggestionButtons[i].innerText = nextWords[i];\n      }\n      else {\n        suggestionButtons[i].innerText = \"\";\n      }\n    }\n  }\n}\n\n\nfunction refreshButtons() {\n  const buttons = document.querySelectorAll('nav button:not(.current)');\n\n  if (!vocabulary || Object.keys(vocabulary).length === 0) {\n    for (let i=0; i<buttons.length; i++) {\n      buttons[i].classList.add('unavailable');\n    }\n  }\n  else {\n    for (let i=0; i<buttons.length; i++) {\n      buttons[i].classList.remove('unavailable');\n    }\n  }\n}\n\n\nfunction getLastWord(text) {\n  const tokens = text.split(\" \");\n  return tokens[tokens.length-1];\n}\n\n\nfunction cleanText(text) {\n  /* Removes HTML tags and other characters that will interfere with regexs */\n  return text.replace(/(<([^>]+)>)/ig,\"\").replace(/[\\s\\s,\\t \\n,]+/g, \" \").replace(/[\\]*\\[*\\(*\\)*\\_*]/g, \"\").trim();\n}\n\n\nasync function getWikiText() {\n  return new Promise((resolve, reject) => {\n    // Get random article title:\n    const randomURL = 'https://en.wikipedia.org/w/api.php?action=query&origin=*&generator=random&grnnamespace=0&prop=content&exchars=500&format=json';\n    fetch(randomURL).then(response => { return response.json(); })\n    .then((data) => {\n      let pageID = Object.keys(data[\"query\"][\"pages\"])[0];\n      let title = data[\"query\"][\"pages\"][pageID][\"title\"];\n      let formattedTitle = title.replace(/\\s+/g, \"_\");\n      console.log(\"Reading article: '\" + title + \"'\");\n\n      const article = document.createElement(\"li\");\n      const articleText = document.createTextNode(\"Reading article: \\\"\" + title + \"\\\"\");\n      article.appendChild(articleText);\n      document.getElementById('wiki-history').prepend(article);\n\n      // Now fetch its text contents:\n      const contentURL = 'https://en.wikipedia.org/w/api.php?action=query&origin=*&prop=extracts&explaintext&format=json&titles=';\n      fetch(contentURL + formattedTitle)\n      .then(response => { return response.json(); })\n      .then( pageData => {\n        let page = Object.keys(pageData['query']['pages'])[0];\n        let text = pageData['query']['pages'][page]['extract'];\n        cleanWikiText(text).then(formattedText => {\n          resolve(formattedText);\n        });\n      });\n    })\n    .catch(err => {\n      reject(err);\n    });\n  });\n}\n\n\nfunction cleanWikiText(wikiText) {\n  /* Removes markup and excessive spacing from Wikipedia text */\n\n  return new Promise((resolve, reject) => {\n    let headings = [\"======\", \"=====\", \"====\", \"===\", \"==\"];\n    let workingText = wikiText;\n    let chunks;\n\n    // Remove each heading:\n    const removeHeadings = new Promise((resolve, reject) => {\n      for (let i=0; i<headings.length; i++) {\n        let edits = [];\n        chunks = workingText.split(headings[i]);\n\n        if (chunks.length > 2) {\n          for (let j=0; j<chunks.length; j++) {\n            if (j%2 == 0) {\n              // Odd number, add to array\n              edits.push(chunks[j]);\n            }\n          }\n\n          workingText = edits.join(\"\");\n        }\n\n        if (i == headings.length-1) {\n          // Done with loop\n          resolve(workingText);\n        }\n      }\n    });\n\n\n    removeHeadings.then((finalText) => {\n      //Remove excessive spaces:\n      finalText = finalText.replace(/\\s\\s+/g, ' ');\n      resolve(finalText);\n    });\n  });\n}\n\n\nfunction speakText(text) {\n  if ('speechSynthesis' in window) {\n    const utterance = new SpeechSynthesisUtterance();\n\n    //Load voices before proceeding:\n    const loadingVoices = setInterval( () => {\n      const voices = window.speechSynthesis.getVoices();\n\n      if (voices.length > 0) {\n        utterance.voice = voices[0];\n        utterance.lang = 'en-US';\n        utterance.rate = 0.85;\n        utterance.pitch = 1;\n        utterance.text = text;\n\n        speechSynthesis.speak(utterance);\n        clearInterval(loadingVoices);\n      }\n    }, 500);\n  }\n}\n\n//# sourceURL=webpack:///./Demo/main.js?");

/***/ }),

/***/ "./Markov.js":
/*!*******************!*\
  !*** ./Markov.js ***!
  \*******************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("const allData = {\n  vocabulary: {},\n  sentenceStarters: [],\n  sentenceEnders: []\n};\n\n\nfunction getVocabulary() {\n  return allData.vocabulary;\n}\n\n\nfunction loadVocabulary() {\n  return fetch('../utilities/getVocabulary.php')\n  .then(response => response.json())\n  .then((data) => {\n    if (data) {\n      allData.vocabulary = data.vocabulary;\n      allData.sentenceStarters = data.sentenceStarters;\n      allData.sentenceEnders = data.sentenceEnders;\n      console.log(\"Vocabulary loaded\");\n    }\n    else {\n      allData.vocabulary = {};\n    }\n  })\n  .catch((err) => {\n    console.warn(\"Unable to fetch vocabulary. The JSON file is most likely empty. \\nCreating a new vocabulary object...\");\n    allData.vocabulary = {};\n  });\n}\n\n\nfunction saveVocabulary(obj) {\n  return new Promise((resolve, reject) => {\n    const xhr = new XMLHttpRequest();\n    xhr.open('POST', '../utilities/saveVocabulary.php');\n    xhr.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\");\n    xhr.onload = () => {\n      if (xhr.status === 200) {\n        // console.log(\"Saved!\");\n        resolve();\n      }\n    };\n    xhr.send(\"data=\" + encodeURIComponent(JSON.stringify(obj)));\n  });\n}\n\n\nfunction train(text) {\n  return new Promise((resolve, reject) => {\n    let tokens = cleanText(text).split(\" \");\n\n    for (let i=0; i<tokens.length; i++) {\n      const prevWord = (i-1 > -1) ? tokens[i-1] : null;\n      const thisWord = tokens[i];\n      const nextWord = (i+1 < tokens.length) ? tokens[i+1] : null;\n\n      if (thisWord in allData.vocabulary) {\n        // Word is already in vocabulary, only add its next word:\n        if (nextWord) {\n          allData.vocabulary[thisWord].push(nextWord);\n        }\n      }\n      else {\n        // Not yet in vocabulary, add it & its next word:\n        allData.vocabulary[thisWord] = [];\n        if (i+1 < tokens.length) {\n          allData.vocabulary[thisWord].push(tokens[i+1]);\n        }\n      }\n\n      // Record sentence starters / enders:\n      if (prevWord && prevWord.charAt(prevWord.length-1).match(/[.:!?]/)) {\n        if (allData.sentenceEnders.indexOf(prevWord) === -1) {\n          allData.sentenceEnders.push(prevWord);\n        }\n        if (allData.sentenceStarters.indexOf(thisWord) === -1) {\n          allData.sentenceStarters.push(thisWord);\n        }\n      }\n      else if (i === 0) {\n        if (allData.sentenceStarters.indexOf(thisWord) === -1) {\n          allData.sentenceStarters.push(thisWord);\n        }\n      }\n    }\n\n    for (let words in allData.vocabulary) {\n      allData.vocabulary[words] = sortByOccurrence(allData.vocabulary[words]);\n    }\n    resolve();\n  }).then(() => {\n    return saveVocabulary(allData);\n  });\n}\n\n\nfunction cleanText(text) {\n  /* Removes HTML tags and other characters from Wikipedia that will interfere with regexs */\n  return text.replace(/(<([^>]+)>)/ig,\"\").replace(/[\\s\\s,\\t \\n,]+/g, \" \").replace(/[\\]*\\[*\\(*\\)*\\_*]/g, \"\").trim();\n}\n\n\nfunction generateParagraph(limit) {\n  const words = Object.keys(allData.vocabulary);\n  const startIndex = Math.floor(Math.random() * (allData.sentenceStarters.length));\n  let firstWord = allData.sentenceStarters[startIndex];\n  let nextWord = allData.vocabulary[firstWord][0];\n  firstWord = firstWord.charAt(0).toUpperCase() + firstWord.slice(1);\n  let capitalize = (firstWord.search(/(\\.|\\?|!)/g) != -1) ? true : false;\n  const paragraph = [firstWord];\n  let iterator = 0;\n\n  while (nextWord && iterator < limit) {\n    let thisWord = nextWord;\n\n    if (capitalize) {\n      // Capitalize first letter of new sentence\n      thisWord = thisWord.charAt(0).toUpperCase() + thisWord.slice(1);\n      capitalize = false;\n    }\n    paragraph.push(\" \" + thisWord);\n\n    let nextIndex;\n    let possibleNextWords;\n\n    if (thisWord.charAt(thisWord.length-1).match(/[.:!?]/)) {\n      // End of sentence, start with a sentenceStarter\n      possibleNextWords = allData.sentenceStarters;\n    }\n    else {\n      possibleNextWords = allData.vocabulary[thisWord]\n    }\n\n    if (typeof possibleNextWords != 'undefined' && possibleNextWords.length > 0) {\n      nextIndex = Math.floor( Math.random() * (possibleNextWords.length) );\n      nextWord = possibleNextWords[nextIndex];\n    }\n    else {\n      // No words available, randomize next word:\n      nextWord = words[Math.floor(Math.random() * (words.length))];\n    }\n\n    capitalize = (thisWord.search(/(\\.|\\?|!)/g) != -1) ? true : false;\n    iterator++;\n  }\n\n  return paragraph.join('');\n}\n\n\nfunction sortByOccurrence(word) {\n  const count = {};\n  let sortedList = [];\n\n  // Count occurrence of each word:\n  for (let i=0; i<word.length; i++) {\n    if (word[i] in count) {\n      count[word[i]]++;\n    }\n    else {\n      count[word[i]] = 1;\n    }\n  }\n\n  // Sort:\n  sortedList = Object.keys(count).sort( (a, b) => {\n    return count[b] - count[a];\n  });\n\n  return sortedList;\n}\n\n\nfunction predictPath(text) {\n  let possibilities = {};\n  possibilities.one = allData.vocabulary[text];\n  if (possibilities.one.length > 0) {\n    possibilities.two = allData.vocabulary[possibilities.one[0]];\n    if (possibilities.two.length > 0) {\n      possibilities.three = allData.vocabulary[possibilities.two[0]];\n    }\n  }\n\n  return possibilities;\n}\n\n\nmodule.exports = {\n  getVocabulary: getVocabulary,\n  loadVocabulary: loadVocabulary,\n  train: train,\n  predictPath: predictPath,\n  generateParagraph: generateParagraph,\n}\n\n//# sourceURL=webpack:///./Markov.js?");

/***/ }),

/***/ "./node_modules/haystack-search/Haystack.js":
/*!**************************************************!*\
  !*** ./node_modules/haystack-search/Haystack.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*\n * Haystack.js\n * By: Alexander Lyon\n * Version 4.4.2\n * https://github.com/AlexanderLyon/Haystack\n */\n\nconst stemmer = __webpack_require__(/*! stemmer */ \"./node_modules/stemmer/index.js\");\n\nclass Haystack {\n  constructor(...args) {\n    // Default options:\n    const defaults = {\n      caseSensitive: false,\n      flexibility: 2,\n      stemming: false,\n      exclusions: null,\n      ignoreStopWords: false\n    };\n\n    // Override defaults with passed in options:\n    if (args[0] && typeof args[0] === 'object') {\n      this.options = extendDefaults(defaults, args[0]);\n    }\n    else {\n      this.options = defaults;\n    }\n  }\n\n\n\n  /**\n   * Returns an array of matches, or null if no matches are found\n   * @param {string} query user-entered query\n   * @param {string[]|Object} source data to search\n   * @param {number} [limit=1] maximum number of results returned\n   * @return {Array} Sorted array of matches\n   */\n  search(query, source, limit) {\n    try {\n      if (typeof query !== 'string') {\n        throw new Error('Invalid search query');\n      }\n      else if ((typeof source === 'undefined') || (typeof source === 'number')) {\n        throw new Error('Invalid source type: ' + typeof source);\n      }\n    }\n    catch (e) {\n      console.error(e);\n      return;\n    }\n\n    limit = (typeof limit !== 'undefined') ? limit : 1;\n    const sourceDataType = getDataType(source);\n    source = (sourceDataType === 'string') ? this.tokenize(source) : source;\n    let results = [];\n    let tokens;\n\n    if (query != '') {\n      query = prepareQuery(query, this.options);\n      tokens = this.tokenize(query);\n\n      /* Search */\n      let searchResults;\n      switch (sourceDataType) {\n        case 'array':\n        case 'string':\n          searchResults = searchArray(source, query, tokens, this.options);\n          break;\n        case 'object':\n          searchResults = searchObject(source, query, tokens, this.options);\n          break;\n      }\n\n      if (searchResults.length > 0) {\n        for (let i=0; i<searchResults.length; i++) {\n          results.push(searchResults[i]);\n        }\n      }\n\n      // Sort and return either the results array, or null:\n      if (results == '') {\n        return null;\n      }\n      else {\n        return sortResults( createUniqueArray(results), query ).slice(0, limit);\n      }\n    }\n    else {\n      // No query present\n      return null;\n    }\n  }\n\n\n\n  /**\n   * Splits a string into tokens based on specified delimiter\n   * @param {string} input text to tokenize\n   * @param {string} delimiter the points where the split should occur\n   * @return {Array} array of tokens\n   */\n  tokenize(input, delimiter) {\n    delimiter = (typeof delimiter !== 'undefined') ? delimiter : ' ';\n    return input.split(delimiter);\n  }\n}\n\n\n\nfunction extendDefaults(defaults, properties) {\n  /* Extends defaults with user options */\n  for (let property in properties) {\n    if (properties.hasOwnProperty(property)) {\n      defaults[property] = properties[property];\n    }\n  }\n  return defaults;\n}\n\n\nfunction prepareQuery(query, options) {\n  /* Cleans and formats query based on defined options */\n  let tokens;\n\n  if (options.ignoreStopWords) {\n    query = removeStopWords(query);\n  }\n\n  if (options.exclusions) {\n    query = query.replace(options.exclusions, '');\n  }\n\n  if (options.caseSensitive) {\n    query = query.trim();\n    tokens = query.split(' ');\n  }\n  else {\n    query = query.trim().toLowerCase();\n    tokens = query.split(' ');\n  }\n\n  if (options.stemming) {\n    for (let i=0; i<tokens.length; i++) {\n      tokens[i] = stemmer(tokens[i]);\n    }\n    query = tokens.join(\" \");\n  }\n\n  return query;\n}\n\n\nfunction searchArray(source, query, tokens, options) {\n  let currentResults = [];\n\n  for (let i=0; i<source.length; i++) {\n    // Make sure value is a string:\n    source[i] = options.caseSensitive ? String(source[i]) : String(source[i]).toLowerCase();\n\n    // Test if every token is found:\n    let allTokensFound = true;\n    for (let j=0; j<tokens.length; j++) {\n      if (source[i].indexOf(tokens[j]) === -1) {\n        allTokensFound = false;\n        break;\n      }\n    }\n\n    if (allTokensFound) {\n      // Exact match\n      currentResults.push(source[i]);\n    }\n    else if ((options.flexibility > 0) && (levenshtein(query.toLowerCase(), source[i].toLowerCase()) <= options.flexibility)) {\n      // Flexibility is set, and this value is within acceptable range\n      currentResults.push(source[i]);\n    }\n  }\n\n  return currentResults;\n}\n\n\nfunction searchObject(obj, query, tokens, options, currentResults) {\n  /* Recursively searches an object for token matches */\n  currentResults = (typeof currentResults !== 'undefined') ? currentResults : [];\n\n  for (let key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      let value = obj[key];\n\n      if (getDataType(value) === 'object') {\n        currentResults = searchObject(value, query, tokens, options, currentResults);\n      }\n      else {\n        // Make sure value is a string:\n        value = options.caseSensitive ? String(value) : String(value).toLowerCase();\n\n        // Test if every token is found:\n        let allTokensFound = true;\n        for (let i=0; i<tokens.length; i++) {\n          if (value.indexOf(tokens[i]) === -1) {\n            allTokensFound = false;\n            break;\n          }\n        }\n\n        if (allTokensFound) {\n          // Exact match\n          currentResults.push(value);\n        }\n        else if ((options.flexibility > 0) && (levenshtein(query.toLowerCase(), value.toLowerCase()) <= options.flexibility)) {\n          // Flexibility is set, and this value is within acceptable range\n          currentResults.push(value);\n        }\n      }\n    }\n  }\n\n  return currentResults;\n}\n\n\n/**\n * Returns numeric Levenshtein distance between two strings\n * @param {string} word1 first word\n * @param {string} word2 second word\n * @return {number} Levenshtein distance\n */\nfunction levenshtein(word1, word2) {\n  /* Returns numeric Levenshtein distance between two strings */\n  let cost = [];\n  let str1 = word1;\n  let str2 = word2;\n  let n = str1.length;\n  let m = word1.length;\n  let i;\n  let j;\n  let minimum = function(a, b, c) {\n    let min = a;\n    if (b < min) {\n      min = b;\n    }\n    if (c < min) {\n      min = c;\n    }\n    return min;\n  };\n  if (n == 0) {\n    return;\n  }\n  if (m == 0) {\n    return;\n  }\n  for (let i = 0; i <= n; i++) {\n    cost[i] = [];\n  }\n  for (i = 0; i <= n; i++) {\n    cost[i][0] = i;\n  }\n  for (j = 0; j <= m; j++) {\n    cost[0][j] = j;\n  }\n  for (i = 1; i <= n; i++) {\n    let x = str1.charAt(i - 1);\n    for (j = 1; j <= m; j++) {\n      let y = str2.charAt(j - 1);\n      if (x == y) {\n        cost[i][j] = cost[i - 1][j - 1];\n      }\n      else {\n        cost[i][j] = 1 + minimum(cost[i - 1][j - 1], cost[i][j - 1], cost[i - 1][j]);\n      }\n    }\n  }\n  return cost[n][m];\n}\n\n\nfunction sortResults(results, query) {\n  /* Sorts results in ascending order */\n  let swapped;\n  do {\n    swapped = false;\n    for (let i = 0; i < results.length; i++) {\n      if (results[i] && results[i+1] && levenshtein(query, results[i]) > levenshtein(query, results[i+1])) {\n        let temp = results[i];\n        results[i] = results[i+1];\n        results[i+1] = temp;\n        swapped = true;\n      }\n    }\n  } while (swapped);\n  return results;\n}\n\n\nfunction createUniqueArray(arr) {\n  /* Removes duplicates from an array */\n  let uniqueArray = arr.filter(function(item, pos) {\n    return arr.indexOf(item) == pos;\n  });\n  return uniqueArray;\n}\n\n\nfunction getDataType(source) {\n  if (source) {\n    if (typeof source === 'object' && source.constructor === Array) {\n      return 'array';\n    }\n    else if (typeof source === 'object' && source.constructor === Object) {\n      return 'object';\n    }\n    else if (typeof source === 'string' && source.constructor === String) {\n      return 'string';\n    }\n  }\n  else {\n    return null;\n  }\n}\n\n\nfunction removeStopWords(query) {\n  /* Removes common stop words from the query */\n  let words = query.split(' ');\n  let newQuery = [];\n\n  // Mark stop word tokens as 'undefined'\n  for (let i=0; i<words.length; i++) {\n    switch (words[i].toLowerCase()) {\n      case 'the':\n      case 'a':\n      case 'to':\n      case 'on':\n      case 'in':\n      case 'is':\n      case 'of':\n      case 'and':\n        words[i] = undefined;\n        break;\n    }\n  }\n\n  // Only move elements that are defined to 'newQuery' array\n  for (let i=0; i<words.length; i++) {\n    if (words[i] != undefined) {\n      newQuery.push(words[i]);\n    }\n  }\n\n  return newQuery.join(' ');\n}\n\n\nmodule.exports = Haystack;\n\n\n//# sourceURL=webpack:///./node_modules/haystack-search/Haystack.js?");

/***/ }),

/***/ "./node_modules/stemmer/index.js":
/*!***************************************!*\
  !*** ./node_modules/stemmer/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = stemmer\n\n// Standard suffix manipulations.\nvar step2list = {\n  ational: 'ate',\n  tional: 'tion',\n  enci: 'ence',\n  anci: 'ance',\n  izer: 'ize',\n  bli: 'ble',\n  alli: 'al',\n  entli: 'ent',\n  eli: 'e',\n  ousli: 'ous',\n  ization: 'ize',\n  ation: 'ate',\n  ator: 'ate',\n  alism: 'al',\n  iveness: 'ive',\n  fulness: 'ful',\n  ousness: 'ous',\n  aliti: 'al',\n  iviti: 'ive',\n  biliti: 'ble',\n  logi: 'log'\n}\n\nvar step3list = {\n  icate: 'ic',\n  ative: '',\n  alize: 'al',\n  iciti: 'ic',\n  ical: 'ic',\n  ful: '',\n  ness: ''\n}\n\n// Consonant-vowel sequences.\nvar consonant = '[^aeiou]'\nvar vowel = '[aeiouy]'\nvar consonants = '(' + consonant + '[^aeiouy]*)'\nvar vowels = '(' + vowel + '[aeiou]*)'\n\nvar gt0 = new RegExp('^' + consonants + '?' + vowels + consonants)\nvar eq1 = new RegExp(\n  '^' + consonants + '?' + vowels + consonants + vowels + '?$'\n)\nvar gt1 = new RegExp('^' + consonants + '?(' + vowels + consonants + '){2,}')\nvar vowelInStem = new RegExp('^' + consonants + '?' + vowel)\nvar consonantLike = new RegExp('^' + consonants + vowel + '[^aeiouwxy]$')\n\n// Exception expressions.\nvar sfxLl = /ll$/\nvar sfxE = /^(.+?)e$/\nvar sfxY = /^(.+?)y$/\nvar sfxIon = /^(.+?(s|t))(ion)$/\nvar sfxEdOrIng = /^(.+?)(ed|ing)$/\nvar sfxAtOrBlOrIz = /(at|bl|iz)$/\nvar sfxEED = /^(.+?)eed$/\nvar sfxS = /^.+?[^s]s$/\nvar sfxSsesOrIes = /^.+?(ss|i)es$/\nvar sfxMultiConsonantLike = /([^aeiouylsz])\\1$/\nvar step2 = new RegExp(\n  '^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$'\n)\nvar step3 = /^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/\nvar step4 = new RegExp(\n  '^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$'\n)\n\n// Stem `value`.\nfunction stemmer(value) {\n  var firstCharacterWasLowerCaseY\n  var match\n\n  value = String(value).toLowerCase()\n\n  // Exit early.\n  if (value.length < 3) {\n    return value\n  }\n\n  // Detect initial `y`, make sure it never matches.\n  if (value.charCodeAt(0) === 121 /* y */) {\n    firstCharacterWasLowerCaseY = true\n    value = 'Y' + value.substr(1)\n  }\n\n  // Step 1a.\n  if (sfxSsesOrIes.test(value)) {\n    // Remove last two characters.\n    value = value.substr(0, value.length - 2)\n  } else if (sfxS.test(value)) {\n    // Remove last character.\n    value = value.substr(0, value.length - 1)\n  }\n\n  // Step 1b.\n  if ((match = sfxEED.exec(value))) {\n    if (gt0.test(match[1])) {\n      // Remove last character.\n      value = value.substr(0, value.length - 1)\n    }\n  } else if ((match = sfxEdOrIng.exec(value)) && vowelInStem.test(match[1])) {\n    value = match[1]\n\n    if (sfxAtOrBlOrIz.test(value)) {\n      // Append `e`.\n      value += 'e'\n    } else if (sfxMultiConsonantLike.test(value)) {\n      // Remove last character.\n      value = value.substr(0, value.length - 1)\n    } else if (consonantLike.test(value)) {\n      // Append `e`.\n      value += 'e'\n    }\n  }\n\n  // Step 1c.\n  if ((match = sfxY.exec(value)) && vowelInStem.test(match[1])) {\n    // Remove suffixing `y` and append `i`.\n    value = match[1] + 'i'\n  }\n\n  // Step 2.\n  if ((match = step2.exec(value)) && gt0.test(match[1])) {\n    value = match[1] + step2list[match[2]]\n  }\n\n  // Step 3.\n  if ((match = step3.exec(value)) && gt0.test(match[1])) {\n    value = match[1] + step3list[match[2]]\n  }\n\n  // Step 4.\n  if ((match = step4.exec(value))) {\n    if (gt1.test(match[1])) {\n      value = match[1]\n    }\n  } else if ((match = sfxIon.exec(value)) && gt1.test(match[1])) {\n    value = match[1]\n  }\n\n  // Step 5.\n  if (\n    (match = sfxE.exec(value)) &&\n    (gt1.test(match[1]) ||\n      (eq1.test(match[1]) && !consonantLike.test(match[1])))\n  ) {\n    value = match[1]\n  }\n\n  if (sfxLl.test(value) && gt1.test(value)) {\n    value = value.substr(0, value.length - 1)\n  }\n\n  // Turn initial `Y` back to `y`.\n  if (firstCharacterWasLowerCaseY) {\n    value = 'y' + value.substr(1)\n  }\n\n  return value\n}\n\n\n//# sourceURL=webpack:///./node_modules/stemmer/index.js?");

/***/ })

/******/ });